#!/usr/bin/env python
#     Copyright 2012, Kay Hayen, mailto:kayhayen@gmx.de
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     If you submit patches or make the software available to licensors of
#     this software in either form, you automatically them grant them a
#     license for your part of the code under "Apache License 2.0" unless you
#     choose to remove this notice.
#
#     Kay Hayen uses the right to license his code under only GPL version 3,
#     to discourage a fork of Nuitka before it is "finished". He will later
#     make a new "Nuitka" release fully under "Apache License 2.0".
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, version 3 of the License.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#     Please leave the whole of this copyright notice intact.
#

# Disabled globally:
#
# W0232: Class has no __init__ method
# Who cares, I am using overrides that don't need to change object init a lot
# and I rarely ever made a mistake with forgetting to call __init__ of the
# parent.
#
# I0011: Locally disabling W....
# Strange one anyway, I want to locally disable stuff. And that just makes it
# a different warning. Amazing. Luckily I can decide to ignore that globally
# then.

import sys, os, subprocess

# Go its own directory, to have it easy with path knowledge.
os.chdir( os.path.dirname( os.path.abspath( __file__ ) ) )
os.chdir( ".." )

options = """
--rcfile=/dev/null
--include-ids=y
--disable=I0011,W0232
--reports=no
--persistent=no
--method-rgx=[a-z_][a-zA-Z0-9_]{2,40}$
--module-rgx=.*
--function-rgx=.*
--variable-rgx=.*
--argument-rgx=.*
--const-rgx=.*
--max-line-length=120
--no-docstring-rgx=.*
--max-module-lines=5000
--min-public-methods=0
--max-public-methods=100
--max-args=10
--max-parents=9
""".split()

if os.environ.get( "TODO", 0 ):
    options.append( "--notes=" )

blacklist = (
    "oset.py",
    "odict.py",
    "SyntaxHighlighting.py",
    "TreeDisplay.py"
)

def executePyLint( filename ):
    command = "pylint %s %s %s" % (
        " ".join( options ),
        os.environ.get( "PYLINT_EXTRA_OPTIONS", "" ),
        filename
    )

    process = subprocess.Popen(
        args   = command,
        stdout = subprocess.PIPE,
        stderr = subprocess.STDOUT,
        shell  = True
    )

    stdout, _stderr = process.communicate()
    exit_code = process.returncode

    assert not _stderr
    if stdout:
        for line in stdout.split( b"\n" ):
            print( line.decode() )

    sys.stdout.flush()

if "PYTHONPATH" not in os.environ:
    os.environ[ "PYTHONPATH" ] = "."

if len( sys.argv ) >= 2:
    executePyLint( sys.argv[ 1 ] )
else:
    executePyLint( "bin/nuitka" )

    for dirpath, dirnames, filenames in os.walk( "nuitka" ):
        dirnames.sort()

        if "inline_copy" in dirnames:
            dirnames.remove( "inline_copy" )

        for filename in filenames:
            if not filename.endswith( ".py" ):
                continue

            if filename not in blacklist:
                executePyLint( os.path.join( dirpath, filename ) )
