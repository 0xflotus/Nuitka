# -*- python -*-
#     Copyright 2012, Kay Hayen, mailto:kayhayen@gmx.de
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     If you submit patches or make the software available to licensors of
#     this software in either form, you automatically them grant them a
#     license for your part of the code under "Apache License 2.0" unless you
#     choose to remove this notice.
#
#     Kay Hayen uses the right to license his code under only GPL version 3,
#     to discourage a fork of Nuitka before it is "finished". He will later
#     make a new "Nuitka" release fully under "Apache License 2.0".
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, version 3 of the License.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#     Please leave the whole of this copyright notice intact.
#

# The Nuitka scons file. If you have Scons knowledge, please feel free and contribute
# improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no build
# process for itself, although it can be compiled using the same method.

import os, subprocess, sys

# The directory containing the C++ files generated by Nuitka to be built using scons. They are
# referred to as sources from here on.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory containing Nuitka provided C++ files to be built.
nuitka_src = os.path.join( os.environ.get( "NUITKA_SCONS" ), "static_src" )
static_src = source_dir + "/static"

# We tell Scons that it is a variant to be built, so object files don't end up inside that
# directory which need not be writable.
VariantDir( static_src, nuitka_src, 0 )

# The name of what we should produce. By default it's the same as what we started with,
# but you (or Nuitka) could override it.
result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )


# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# LTO mode: Use link time optimizations of g++ compiler if available and known good with
# the compiler in question. The 4.5 one didn't have good enough support, the compiled
# result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", "win" in sys.platform )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# ARM target mode: Compile for ARM which has bad ucontext status, we need
# to provide our own implementation.
arm_linux_target = getBoolOption( "arm_linux_target", "linux" in sys.platform and "arm" in os.uname()[4] )

# x64 target mode: Compile for x64 which swapcontext that does syscall that is not
# necessary. We choose to provide our own implementation.
x64_linux_target = getBoolOption( "x64_linux_target", "linux" in sys.platform and "x86_64" == os.uname()[4] and not win_target )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# The MingW compiler tool should be supported if targeting windows.
if win_target:
    compiler_tools = [ "mingw" ]
else:
    compiler_tools = None

env = Environment(
    # We want the outside environment to be passed through.
    ENV = os.environ,

    # Extra tools configuration for scons.
    tools = compiler_tools,

    # The shared libraries should not be named "lib...", because CPython requires the
    # filename "module_name.so" to load it.
    SHLIBPREFIX = "",
)

# To work around Windows not supporting command lines of greater than 10K by default:

class CustomSpawn( object ):

    def spawn( self, sh, escape, cmd, args, env ):
        newargs = ' '.join(args[1:])
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if rv:
            raise RuntimeError( err )

        return rv

def setupSpawn( env ):
    buf = CustomSpawn()
    buf.ourenv = env
    env[ "SPAWN" ] = buf.spawn

if "win" in sys.platform:
    setupSpawn( env )

# To support cross-compiling under Linux for a  windows target, a cross compiler linked or
# installed to /opt/mingw will win over a system installed one.
if win_target and "linux" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    import SCons, re

    pipe = SCons.Action._subproc(
        env, [env[ "CXX" ], '--version'],
        stdin = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search(r'[0-9]+(\.[0-9]+)+', line)
    assert match, line

    env[ "CXXVERSION" ] = match.group(0)

env[ "BUILD_DIR" ] = source_dir

if "g++" in env[ "CXX" ]:
    # All Nuitka generated C++ is C++0X standard, so make that clear.
    env.Append( CCFLAGS = [ "-std=c++0x" ] )

    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [ "-fvisibility=hidden", "-fvisibility-inlines-hidden" ] )

    # Allow g++ to point out all kinds of inconsistency to us by raising an error. As for
    # sequence points, we are abusing it, so we have to allow it.
    if debug_mode:
        env.Append( CCFLAGS = [ "-Wall", "-Werror", "-Wno-sequence-point" ] )

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5 binary if it's
    # not high enough. This is esp. useful under Debian which allows all compiler to exist
    # next to  each other and where g++ might not be good enough, but g++-4.5 would be.
    if gpp_version < 450:
        if not win_target and os.path.exists( "/usr/bin/g++-4.5" ):
            env[ "CXX" ] = "g++-4.5"
            gpp_version = 450
        else:
            sys.exit( "The g++ compiler %s (version %s) doesn't have the sufficient version (>= 4.5)." % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across files,
    # but unfortunately at this time it seriously slows down the compiled code. This may
    # be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )

if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

if win_target:
    python_version = python_version.replace( ".", "" )

    def guessPythonHome():
        """ Guess the Python home directory.

        Under Windows it can be done from the running Python under Windows. Under
        Linux we take the supposed wine path. Can be overridden by an environment
        variable in any case.
        """

        if "win" in sys.platform:
            return os.path.dirname( sys.executable )
        else:
            return os.path.expanduser( "~/.wine/drive_c/Python" + python_version )

    python_home = os.environ.get( "PYTHON_HOME", guessPythonHome() )

    env.Append( LIBPATH = [ python_home + "/libs" ] )

    env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

    if win_disable_console:
        env.Append( LINKFLAGS = [ "-Wl,--subsystem,windows" ] )

    python_header_path = python_home + "/include"

    # Might be required for native current MinGW to not have a link time issue.
    # -D__MSVCRT_VERSION__=0x0800 -DWINVER=0x0800

else:
    # The python header path is a combination of python version and debug indication, make
    # sure the headers are found by adding it to the C++ include path.
    python_header_path = "/usr/include/python" + python_version

env.Append( CCFLAGS = [ "-I" + python_header_path ] )
env.Append( LIBS = [ "python" + python_version ] )

nuitka_include = os.path.join( os.environ[ "NUITKA_SCONS" ], "include" )
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good tracebacks
    # from it.
    if win_target and "linux" in sys.platform:
        env.Append( CCFLAGS = [ "-gstabs" ] )
        env.Append( ASFLAGS = [ "-gstabs" ] )
    else:
        env.Append( CCFLAGS = [ "-g", "-feliminate-unused-debug-types" ] )
        env.Append( ASFLAGS = [ "-g" ] )

# When debugging, optimize less than when optimizing, when not remove assertions.
if debug_mode:
    env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    env.Append( CCFLAGS = [ "-O3" ] )

if module_mode:
    env.Append( CCFLAGS = [ "-shared" ] )

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    result.append( static_src + "/CompiledFunctionType.cpp" )
    result.append( static_src + "/CompiledGeneratorType.cpp" )
    result.append( static_src + "/CompiledMethodType.cpp" )
    result.append( static_src + "/CompiledGenexprType.cpp" )
    result.append( static_src + "/CompiledCodeHelpers.cpp" )

    if not module_mode:
        result.append( static_src + "/ExeModuleUnfreezer.cpp" )
        result.append( static_src + "/InspectPatcher.cpp" )

    if win_target:
        result.append( static_src + "/win32_ucontext_src/fibers_win32.cpp" )
    elif x64_linux_target:
        result.append( static_src + "/x64_ucontext_src/fibers_x64.cpp" )
        result.append( static_src + "/x64_ucontext_src/swapfiber.S" )
    elif arm_linux_target:
        result.append( static_src + "/arm_ucontext_src/fibers_arm.cpp" )
        result.append( static_src + "/arm_ucontext_src/ucontext.cpp" )
        result.append( static_src + "/arm_ucontext_src/getcontext.asm" )
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append( static_src + "/gen_ucontext_src/fibers_gen.cpp" )

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( source_dir + "/" + filename )

    # Add the resource file for the manifest to be included in the executable.
    if win_target and not module_mode:
        result.append( env.RES( source_dir + "/" + source_name + ".exe.rc" ) )

    return result

# Prepare the use of a custom specs file for windows targets. We change the used specs for
# linking to avoid the use of the wrong (for CPython) run time library.
if win_target:
    manifest_file = open( source_dir + "/" + source_name + ".exe.manifest", "w" )
    manifest_file.write( r"""
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
         type="win32"
         name="Microsoft.VC90.CRT"
         version="9.0.21022.8"
         processorArchitecture="x86"
         publicKeyToken="1fc8b3b9a1e18e3b">
      </assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>
"""
    )
    manifest_file.close()

    rc_file = open( source_dir + "/" + source_name + ".exe.rc", "w" )
    rc_file.write( r"""\
#include "winuser.h"
1 RT_MANIFEST %s
""" % ( source_name + ".exe.manifest" )
    )
    rc_file.close()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary( result_file, discoverSourceFiles() )
else:
    # Avoid dependency on MinGW libraries.
    if win_target:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program( result_file + ".exe", discoverSourceFiles() )

# Remove the target file to avoid cases where it falsely didn't get rebuilt.
if os.path.exists( target[0].abspath ):
    os.unlink( target[0].abspath )

Default( target )
