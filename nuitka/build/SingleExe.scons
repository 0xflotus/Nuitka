# -*- python -*-
#     Copyright 2012, Kay Hayen, mailto:kayhayen@gmx.de
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

# The Nuitka scons file. If you have Scons knowledge, please feel free and contribute
# improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no build
# process for itself, although it can be compiled using the same method.

import os, subprocess, sys, re

# The directory containing the C++ files generated by Nuitka to be built using scons. They are
# referred to as sources from here on.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory containing Nuitka provided C++ files to be built.
nuitka_src = os.path.join( os.environ.get( "NUITKA_SCONS" ), "static_src" )
static_src = os.path.join( source_dir, "static" )

# We tell Scons that it is a variant to be built, so object files don't end up inside that
# directory which need not be writable.
VariantDir( static_src, nuitka_src, 0 )

# The name of what we should produce. By default it's the same as what we started with,
# but you (or Nuitka) could override it.
result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )


# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# LTO mode: Use link time optimizations of g++ compiler if available and known good with
# the compiler in question. The 4.5 one didn't have good enough support, the compiled
# result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", os.name == "nt" )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# ARM target mode: Compile for ARM which has bad ucontext status, we need
# to provide our own implementation.
arm_linux_target = getBoolOption( "arm_linux_target", "linux" in sys.platform and "arm" in os.uname()[4] )

# x64 target mode: Compile for x64 which swapcontext that does syscall that is not
# necessary. We choose to provide our own implementation.
x64_linux_target = getBoolOption( "x64_linux_target", "linux" in sys.platform and "x86_64" == os.uname()[4] and not win_target )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# Clang compiler mode, default on MacOS X, optional on Linux.
clang_mode = getBoolOption( "clang_mode", False ) or sys.platform == "darwin"

# The MingW compiler tool should be supported if targeting windows.
if win_target:
    compiler_tools = [ "mingw" ]
else:
    compiler_tools = None

env = Environment(
    # We want the outside environment to be passed through.
    ENV = os.environ,

    # Extra tools configuration for scons.
    tools = compiler_tools,

    # The shared libraries should not be named "lib...", because CPython requires the
    # filename "module_name.so" to load it.
    SHLIBPREFIX = "",
)

if "CXX" in os.environ:
    env[ "CXX" ] = os.environ[ "CXX" ]

if clang_mode:
    env[ "CXX" ] = "clang"

# To work around Windows not supporting command lines of greater than 10K by default:

class CustomSpawn( object ):

    def spawn( self, sh, escape, cmd, args, env ):
        newargs = ' '.join(args[1:])
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if rv:
            raise RuntimeError( err )

        return rv

def setupSpawn( env ):
    buf = CustomSpawn()
    buf.ourenv = env
    env[ "SPAWN" ] = buf.spawn

if os.name == "nt":
    setupSpawn( env )

def getGccVersion():
    # Update CXXVERSION in env, after we changed it.
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'[0-9]+(\.[0-9]+){2}', line )
    assert match, line

    return match.group(0)


# To support cross-compiling under Linux for a  windows target, a cross compiler linked or
# installed to /opt/mingw will win over a system installed one.
if win_target and "linux" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    env[ "CXXVERSION" ] = getGccVersion()

env[ "BUILD_DIR" ] = source_dir

# Store the file signatures database with the rest of the source files
sconsign_dir = os.path.abspath( os.path.join( source_dir, '.sconsign' ) )

if not os.path.exists( sconsign_dir ):
    os.makedirs( sconsign_dir )

env.SConsignFile( sconsign_dir )

# Support for clang.
if "clang" in env[ "CXX" ]:
    env.Append( CCFLAGS = [ "-std=c++0x", "-w", "-D _XOPEN_SOURCE" ] )
    env.Append( LINKFLAGS = [ "-lstdc++" ])

    # Allow clang to point out all kinds of inconsistency to us by raising an error. As for
    # sequence points, we are abusing it, so we have to allow it.
    if debug_mode:
        env.Append( CCFLAGS = [ "-Wall", "-Werror" ] )


# Support for g++.
if "g++" in env[ "CXX" ]:
    # All Nuitka generated C++ is C++0X standard, so make that clear.
    env.Append( CCFLAGS = [ "-std=c++0x" ] )

    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [ "-fvisibility=hidden", "-fvisibility-inlines-hidden" ] )

    # Allow g++ to point out all kinds of inconsistency to us by raising an error. As for
    # sequence points, we are abusing it, so we have to allow it.
    if debug_mode:
        env.Append( CCFLAGS = [ "-Wall", "-Werror", "-Wno-sequence-point" ] )

    if "CXXVERSION" not in env:
        env[ "CXXVERSION" ] = getGccVersion()

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5 binary if it's
    # not high enough. This is esp. useful under Debian which allows all compiler to exist
    # next to  each other and where g++ might not be good enough, but g++-4.5 would be.
    if gpp_version < 450:
        if not win_target and os.path.exists( "/usr/bin/g++-4.5" ):
            env[ "CXX" ] = "g++-4.5"
            gpp_version = 450
        else:
            sys.exit( "The g++ compiler %s (version %s) doesn't have the sufficient version (>= 4.5)." % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across files,
    # but unfortunately at this time it seriously slows down the compiled code. This may
    # be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )

if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

if win_target:
    python_version = python_version.replace( ".", "" )

    def guessPythonHome():
        """ Guess the Python home directory.

        Under Windows it can be done from the running Python under Windows. Under
        Linux we take the supposed wine path. Can be overridden by an environment
        variable in any case.
        """

        if os.name == "nt":
            return os.path.dirname( sys.executable )
        else:
            return os.path.expanduser( "~/.wine/drive_c/Python" + python_version )

    python_home = os.environ.get( "PYTHON_HOME", guessPythonHome() )

    env.Append( LIBPATH = [ python_home + "/libs" ] )

    env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

    if win_disable_console:
        env.Append( LINKFLAGS = [ "-Wl,--subsystem,windows" ] )

    python_header_path = python_home + "/include"

    # Might be required for native current MinGW to not have a link time issue.
    # -D__MSVCRT_VERSION__=0x0800 -DWINVER=0x0800

else:
    # The python header path is a combination of python version and debug indication, make
    # sure the headers are found by adding it to the C++ include path.
    python_header_path = "/usr/include/python" + python_version

if not os.path.exists( os.path.join( python_header_path, "Python.h" ) ):
    sys.exit( "Error, no 'Python.h' development headers can be found at '%s', dependency not satisfied!" % python_header_path )

env.Append( CCFLAGS = [ "-I" + python_header_path ] )
env.Append( LIBS = [ "python" + python_version ] )

nuitka_include = os.path.join( os.environ[ "NUITKA_SCONS" ], "include" )
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good tracebacks
    # from it.
    if win_target and "linux" in sys.platform:
        env.Append( CCFLAGS = [ "-gstabs" ] )
        env.Append( ASFLAGS = [ "-gstabs" ] )
    else:
        env.Append( CCFLAGS = [ "-g" ] )
        env.Append( ASFLAGS = [ "-g" ] )

        if "g++" in env[ "CXX" ]:
            env.Append( CCFLAGS = [ "-feliminate-unused-debug-types" ] )

# When debugging, optimize less than when optimizing, when not remove assertions.
if debug_mode:
    env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    env.Append( CCFLAGS = [ "-O3" ] )

if module_mode:
    env.Append( CCFLAGS = [ "-shared" ] )

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    result.append( static_src + "/CompiledFunctionType.cpp" )
    result.append( static_src + "/CompiledGeneratorType.cpp" )
    result.append( static_src + "/CompiledMethodType.cpp" )
    result.append( static_src + "/CompiledCodeHelpers.cpp" )

    if not module_mode:
        result.append( static_src + "/ExeModuleUnfreezer.cpp" )
        result.append( static_src + "/InspectPatcher.cpp" )

    if win_target:
        result.append( static_src + "/win32_ucontext_src/fibers_win32.cpp" )
    elif x64_linux_target:
        result.append( static_src + "/x64_ucontext_src/fibers_x64.cpp" )
        result.append( static_src + "/x64_ucontext_src/swapfiber.S" )
    elif arm_linux_target:
        result.append( static_src + "/arm_ucontext_src/fibers_arm.cpp" )
        result.append( static_src + "/arm_ucontext_src/ucontext.cpp" )
        result.append( static_src + "/arm_ucontext_src/getcontext.asm" )
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append( static_src + "/gen_ucontext_src/fibers_gen.cpp" )

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( os.path.join( source_dir, filename ) )

    # Add the resource file for the manifest to be included in the executable.
    if win_target and not module_mode:
        result.append( env.RES( os.path.join( source_dir, source_name + ".exe.rc" ) ) )

    return result

# Prepare the use of a custom specs file for windows targets. We change the used specs for
# linking to avoid the use of the wrong (for CPython) run time library.
if win_target:
    manifest_file = open( os.path.join(source_dir, source_name + ".exe.manifest" ), "w" )
    manifest_file.write( r"""
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
         type="win32"
         name="Microsoft.VC90.CRT"
         version="9.0.21022.8"
         processorArchitecture="x86"
         publicKeyToken="1fc8b3b9a1e18e3b">
      </assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>
"""
    )
    manifest_file.close()

    rc_file = open( os.path.join( source_dir, source_name + ".exe.rc" ), "w" )
    rc_file.write( r"""
#include "winuser.h"
1 RT_MANIFEST %s
""" % ( source_name + ".exe.manifest" )
    )
    rc_file.close()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary( result_file, discoverSourceFiles() )
else:
    # Avoid dependency on MinGW libraries.
    if win_target:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program( result_file + ".exe", discoverSourceFiles() )

# Remove the target file to avoid cases where it falsely didn't get rebuilt.
if os.path.exists( target[0].abspath ):
    os.unlink( target[0].abspath )

Default( target )
