# -*- python -*-
#
#     Copyright 2011, Kay Hayen, mailto:kayhayen@gmx.de
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     If you submit Kay Hayen patches to this software in either form, you
#     automatically grant him a copyright assignment to the code, or in the
#     alternative a BSD license to the code, should your jurisdiction prevent
#     this. Obviously it won't affect code that comes to him indirectly or
#     code you don't submit to him.
#
#     This is to reserve my ability to re-license the code at any time, e.g.
#     the PSF. With this version of Nuitka, using it for Closed Source will
#     not be allowed.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, version 3 of the License.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#     Please leave the whole of this copyright notice intact.
#

# The Nuitka scons file. If you have Scons knowledge, please feel free and contribute
# improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no build
# process for itself, although it can be compiled using the same method.

import os, sys

# The directory with the C++ files generated by Nuitka to be built using scons. They are
# called sources from here on.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory with Nuitka provided C++ files to be built.
nuitka_src = os.environ.get( "NUITKA_CPP", "./src/")
static_src = source_dir + "/static"

# We tell Scons that it is a variant to be built, so object files don't end up inside that
# directory which need not be writable.
VariantDir( static_src, nuitka_src, 0 )

# The name of what we should product. By default it's the same as what we started with,
# but you (or Nuitka) could override it.
result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )


# Module mode: Created a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Optimization mode: Optimize as much as you can.
optimize_mode = getBoolOption( "optimize_mode", True )

# LTO mode: Use link time optimizations of g++ compiler if available and known good with
# the compiler in question. The 4.5 one didn't have good enough support, the compiled
# result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", "win" in sys.platform )

unstriped_mode = getBoolOption( "unstriped_mode", False )

# The MingW compiler tool should be supported if targeting windows.
if win_target:
    compiler_tools = [ "mingw" ]
else:
    compiler_tools = None

env = Environment(
    # We want the outside environment to be passed through.
    ENV = os.environ,

    # Extra tools configuration for scons.
    tools = compiler_tools,

    # The shared libraries should not be named "lib...", because CPython requires the
    # filename "module_name.so" to load it.
    SHLIBPREFIX = "",
)

# To support cross-compiling under Linux to windows target, a cross compiler linked or
# installed to /opt/mingw will win over a system installed one.
if win_target and "linux2" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    import SCons, subprocess, re

    pipe = SCons.Action._subproc(
        env, [env[ "CXX" ], '--version'],
        stdin = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search(r'[0-9]+(\.[0-9]+)+', line)
    assert match, line

    env[ "CXXVERSION" ] = match.group(0)

env[ "BUILD_DIR" ] = source_dir

if "g++" in env[ "CXX" ]:
    # All Nuitka generated C++ is C++0X standard, so make that clear.
    env.Append( CCFLAGS = [ "-std=c++0x" ] )

    # Don't export anything by default, should create smaller executables.
    env.Append( CCFLAGS = [ "-fvisibility=hidden", "-fvisibility-inlines-hidden" ] )

    # Allow g++ to point out all kinds of inconsistency to us by raising an error. As to
    # sequence points, we are abusing it, so we have to allow it.
    if debug_mode:
        env.Append( CCFLAGS = [ "-Wall", "-Werror", "-Wno-sequence-point" ] )

    # Version depedent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5 binary if it's
    # not high enough. This is esp. useful under Debian which allows all compiler to exist
    # next to another and where g++ might not be good enough, but g++-4.5 would be.
    if gpp_version < 450:
        if not win_target and os.path.exists( "/usr/bin/g++-4.5" ):
            env[ "CXX" ] = "g++-4.5"
            gpp_version = 450
        else:
            sys.exit( "The g++ compiler %s (version %s) doesn't have the sufficient version (>= 4.5)." % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # For the LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that the gcc can help with optimization across files,
    # but unfortunately at this time it seriously slows down the compiled code. This may
    # be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )
if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

# Python debug version or not.
python_debug = getBoolOption( "python_debug", False )
debug_indicator = "_d" if python_debug else ""

if win_target:
    python_version = python_version.replace( ".", "" )

    def guessPythonHome():
        """ Guess the Python home directory.

        Under Windows it can be done from the running Python under Windows. Under
        Linux we take the supposed wine path. Can be overriden by environment
        variable in any case.
        """

        if "win" in sys.platform:
            return os.path.dirname( sys.executable )
        else:
            return os.path.expanduser( "~/.wine/drive_c/Python" + python_version )

    python_home = os.environ.get( "PYTHON_HOME", guessPythonHome() )

    env.Append( LIBPATH = [ python_home + "/libs" ] )

    env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

    python_header_path = python_home + "/include"

else:
    # The python header path is a combination of python version and debug indication, make
    # sure the heades are found by adding it to the C++ include path.
    python_header_path = "/usr/include/python" + python_version + debug_indicator

env.Append( CCFLAGS = [ "-I" + python_header_path ] )
env.Append( LIBS = [ "python" + python_version + debug_indicator ] )

nuitka_include = os.environ[ "NUITKA_INCLUDE" ]
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if win_target:
    env.Append( CPPPATH = [ static_src + "/win32_ucontext_src" ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good tracebacks
    # from it.
    if win_target and "linux2" in sys.platform:
        env.Append( CCFLAGS = [ "-gstabs" ] )
    else:
        env.Append( CCFLAGS = [ "-g", "-feliminate-unused-debug-types" ] )

# When debugging, optimize less than when optimizing, when not remove the assertions.
if debug_mode:
    env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    env.Append( CCFLAGS = [ "-O3" ] )

if module_mode:
    env.Append( CCFLAGS = [ "-shared" ] )

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    result.append( static_src + "/CompiledFunctionType.cpp" )
    result.append( static_src + "/CompiledGeneratorType.cpp" )
    result.append( static_src + "/CompiledMethodType.cpp" )
    result.append( static_src + "/CompiledGenexprType.cpp" )
    result.append( static_src + "/CompiledCodeHelpers.cpp" )

    if win_target:
        result.append( static_src + "/win32_ucontext_src/ucontext.cpp" )

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( source_dir + "/" + filename )

    # Add the resource file for the manifest to be included in the executable.
    if win_target and not module_mode:
        result.append( env.RES( source_dir + "/" + source_name + ".exe.rc" ) )

    return result

# Prepare the use of a custom specs file for windows targets. We change the used specs for
# linking to avoid the use of the wrong (for CPython) run time library.
if win_target:
    manifest_file = open( source_dir + "/" + source_name + ".exe.manifest", "w" )
    manifest_file.write( r"""
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
         type="win32"
         name="Microsoft.VC90.CRT"
         version="9.0.21022.8"
         processorArchitecture="x86"
         publicKeyToken="1fc8b3b9a1e18e3b">
      </assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>
"""
    )
    manifest_file.close()

    rc_file = open( source_dir + "/" + source_name + ".exe.rc", "w" )
    rc_file.write( r"""\
#include "winuser.h"
1 RT_MANIFEST %s
""" % ( source_name + ".exe.manifest" )
    )
    rc_file.close()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary( result_file , discoverSourceFiles() )
else:
    target = env.Program( result_file + ".exe", discoverSourceFiles() )

Default( target )
