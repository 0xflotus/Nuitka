#
#     Copyright 2011, Kay Hayen, mailto:kayhayen@gmx.de
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     If you submit Kay Hayen patches to this software in either form, you
#     automatically grant him a copyright assignment to the code, or in the
#     alternative a BSD license to the code, should your jurisdiction prevent
#     this. Obviously it won't affect code that comes to him indirectly or
#     code you don't submit to him.
#
#     This is to reserve my ability to re-license the code at any time, e.g.
#     the PSF. With this version of Nuitka, using it for Closed Source will
#     not be allowed.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, version 3 of the License.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#     Please leave the whole of this copyright notice intact.
#
# The Nuitka scons file. If you have Scons knowledge, please feel free and contribute
# improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no build
# process for itself, although it can be compiled using the same method.

import os, sys

# The directory with the generated C++ files to be built.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory with Nuitka C++ files to be built. We tell Scons that it is a variant to
# be built, so object files don't end up inside.
nuitka_src = os.environ.get( "NUITKA_CPP", "./src/")
static_src = source_dir + "/static"

VariantDir( static_src, nuitka_src, 0 )

result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )

debug_mode = getBoolOption( "debug_mode", False )
optimize_mode = getBoolOption( "optimize_mode", True )
module_mode = getBoolOption( "module_mode", False )
lto_mode = getBoolOption( "lto_mode", False )
win_target = getBoolOption( "win_target", "win" in sys.platform )

env = Environment(
    # We want the outside environment to be passed through.
    ENV = os.environ,


    # The shared libraries should not be named "lib...", because CPython requires the
    # filename "module_name.so" to load it.
    SHLIBPREFIX = "",
)

# The MingW compiler tool should be supported.
if win_target:
    env.Tool( "mingw" )

# To support cross-compiling under Linux to windows target.
if win_target and "linux2" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"

if env[ "CXX" ] == "g++":
    cpp_version = int( env['CCVERSION'].replace( ".", "" ) )

    if cpp_version < 450:
        env[ "CXX" ] = "g++-4.5"
        cpp_version = 450

    if lto_mode and cpp_version < 460 and os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        cpp_version = 460

    if cpp_version >= 460:
        # TODO: Decide if it gives any gain:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that the gcc can help with optimization across files,
    # but unfortunately at this time it seriously slows down the compiled code. This may
    # be because it needs -O3 option to be effective.

    if cpp_version >= 460 and lto_mode:
        # The gcc 4.6 is not final, so LTO may not be better yet.
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )


    if lto_mode and cpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

env[ "BUILD_DIR" ] = source_dir

# All Nuitka generated C++ is C++0X standard, so make that clear.
env.Append( CCFLAGS = [ "-std=c++0x" ] )

if debug_mode:
   env.Append( CCFLAGS = [ "-Wall", "-Werror", "-Wno-sequence-point" ] )

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )
if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

# Python debug version or not.
python_debug = getBoolOption( "python_debug", False )
debug_indicator = "_d" if python_debug else ""

if win_target:
    python_version = python_version.replace( ".", "" )

    def guessPythonHome():
        """ Guess the Python home directory.

        Under Windows it can be done from the running Python under Windows. Under
        Linux we take the supposed wine path. Can be overriden by environment
        variable in any case.
        """

        if "win" in sys.platform:
            return os.path.normpath( os.path.dirname( sys.executable ) + "/.." )
        else:
            return os.path.expanduser( "~/.wine/drive_c/Python" + python_version )

    python_home = os.environ.get( "PYTHON_HOME", guessPythonHome() )

    env.Append( LIBPATH = [ python_home + "/libs" ] )

    env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

    python_header_path = python_home + "/include"

else:
    # The python header path is a combination of python version and debug indication, make
    # sure the heades are found by adding it to the C++ include path.
    python_header_path = "/usr/include/python" + python_version + debug_indicator

env.Append( CCFLAGS = [ "-I" + python_header_path ] )
env.Append( LIBS = [ "python" + python_version + debug_indicator ] )

nuitka_include = os.environ[ "NUITKA_INCLUDE" ]
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if win_target:
    env.Append( CPPPATH = [ static_src + "/win32_ucontext_src" ] )

if debug_mode:
    # On crosscompile, use debug format that wine understands, so we get good tracebacks
    # from it.
    if win_target and "linux2" in sys.platform:
        env.Append( CCFLAGS = [ "-gstabs" ] )
    else:
        env.Append( CCFLAGS = [ "-g" ] )

    env.Append( CCFLAGS = [ "-O2" ] )

if optimize_mode:
    env.Append( CCFLAGS = [ "-O3" ] )

    if not debug_mode:
        env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if module_mode:
    env.Append( CCFLAGS = [ "-shared" ] )

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )


def discoverSourceFiles():
    result = []

    result.append( static_src + "/CompiledFunctionType.cpp" )
    result.append( static_src + "/CompiledGeneratorType.cpp" )
    result.append( static_src + "/CompiledMethodType.cpp" )
    result.append( static_src + "/CompiledGenexprType.cpp" )
    result.append( static_src + "/CompiledCodeHelpers.cpp" )

    if win_target:
        result.append( static_src + "/win32_ucontext_src/ucontext.cpp" )

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( source_dir + "/" + filename )

    return result

if module_mode:
    if win_target:
        module_suffix = ".dll"

        # The scons doesn't like .dll yet.
        module_suffix = ".so"
    else:
        module_suffix = ".so"

    target = env.SharedLibrary( result_file + module_suffix, discoverSourceFiles() )
else:
    target = env.Program( result_file + ".exe", discoverSourceFiles() )

Default( target )
